import './styles.css'

import { Head, Image, Appear, Notes, Invert, Split } from "mdx-deck"

import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer"
import { shadesOfPurple } from "@code-surfer/themes"

import thanos from './static/thanos_logo.svg'
import prometheus from './static/prometheus_logo.svg'
import redhat from './static/red_hat_logo.png'

import ss_tsdb_01 from './static/ss_tsdb_01.png'

export const theme = shadesOfPurple;

<Head>
	<title>Are you testing your Observability?</title>
</Head>

<CodeSurfer>

```go 6[17:53],7[17:53],11[17:53]
package main

import "fmt"

func main() {
	fmt.Println("Are you testing your Observability?")
	fmt.Println("      --- Metrics Edition ---      ")



	fmt.Println("    GoDays 22.01.2020, Berlin      ")
}
```

</CodeSurfer>

<Notes>

Hello everyone!

We are extremely excited to be here in GoDays conference, and be able to speak about topics we both love:

* observability
* programming in go

At the end of this talk we would like you to know:

* why instrumenting Go applications with actionable metrics is essential
* how to do it quickly and smoothly in Go, how to test it
* last but not the least: what are the common mistakes you should avoid, mistakes that
we seen a lot during our work with Go and metrics in WILD open source WORLD.

But before that: Short introduction!

</Notes>

---

<div style="width: 100%; height: 50%; overflow: auto;">
<img src="https://storage.googleapis.com/gopherizeme.appspot.com/gophers/1a34872cf0ec375b9fc44ce654fc03a5abc42dc4.png" style="height: 90%; float: left;"/>

#### Bartek Plotka

<div style="font-size: 80%">
Principal Software Engineer @ Red Hat<br/>
OpenShift Monitoring Team<br/>
Prometheus and Thanos Maintainer<br/><br/>

<img src="https://raw.githubusercontent.com/kakkoyun/are-you-testing-your-observability/master/static/twitter.png" style="height: 40px; width: 40px;"/> <img src="https://raw.githubusercontent.com/kakkoyun/are-you-testing-your-observability/master/static/github.png" style="height: 40px; width: 40px;"/> @bwplotka
</div>
</div>

<div style="width: 100%; height: 50%; overflow: auto;">
<img src="https://storage.googleapis.com/gopherizeme.appspot.com/gophers/9806438d5acfb3a108eeaab302de0e32f8a489ad.png" style="height: 90%; float: left;"/>

#### Kemal Akkoyun

<div style="font-size: 80%">
Software Engineer @ Red Hat<br/>
OpenShift Monitoring Team<br/>
Thanos Contributor<br/><br/>

<img src="https://raw.githubusercontent.com/kakkoyun/are-you-testing-your-observability/master/static/twitter.png" style="height:40px; width: 40px;"/> @kkakkoyun <span/>
<img src="https://raw.githubusercontent.com/kakkoyun/are-you-testing-your-observability/master/static/github.png" style="height: 40px; width: 40px;"/> @kakkoyun
</div>
</div>

<Notes>

My name is Bartek Plotka, I am an engineer working at Red Hat in the Monitoring team, I love open source and Go.
I am in Prometheus team and I am a co-author of Thanos project, which is a durable system for scaling Prometheus.

With me there is Kemal: Kemal TODO intro

</Notes>

---

<div style="width: 100%; height: 50%; overflow: auto;">
<img src={prometheus} style="height: 50%; margin: auto; display: block; margin-top: 100px;" />
</div>

<div style="width: 100%; height: 50%; overflow: auto;">
<img src={thanos} style="height: 50%; margin: auto; display: block; margin-top: 100px;" />
</div>

<Notes>

We are both working in the same monitoring team for Red Hat.
We are building scalable Observability solutions and platforms for OpenShift.
But also as one of the major part of our work is maintaining Prometheus and Thanos projects on a daily basis.

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;"> Let's implement an HTTP L7 loadbalancer in Go! ❤ </h2>

️*Because why not?*

<Appear>
   <img src="https://docs.google.com/drawings/d/e/2PACX-1vQKHs_qMJWPKulEUxoDcLXww4Kq32IcJfPLbnnBfUDMj3AxQzuhRJtCKbw-i6TgqhBoRCfWo7RnV1nm/pub?w=960&h=720"/>
</Appear>

<Notes>

So let's do something fun! Let's implement application level HTTP loadbalancer in Go? Why?
Well these days with replicated microservices loadbalancer are crucial. HTTP is the most popular
protocol this days for API communication, and application level loadbalancing gives us more control
in terms of things like request based load balancing instead of connection based, graceful shutdowns,
inspection and distribution of load.

Appear:

So let's say we implemented transparent loadbalancer as presented in this diagram. From high level design we have:

* single HTTP server that implements ServerHTTP method, so handler via awesome ReverseProxy in standard httputil package.
* ReverseProxy allows us to implement custom Transport, so RoundTripper interface which is to send
some request to remote backend.
* our load balancing RoundTipper implementation called lbtranport is internally using then few components:

  * Discoverer which gives us targets to proxy / loadbalance request to
  * RoundRobinPicker which chooses right target to proxy user request to in round robin manner, so: replica 1, 2,3, then again 1, 2, 3
  * And at the end it uses HTTP transport so, http.RoundTripper that belongs to picked target and proxy request through and proxy response back to the user.

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vQKHs_qMJWPKulEUxoDcLXww4Kq32IcJfPLbnnBfUDMj3AxQzuhRJtCKbw-i6TgqhBoRCfWo7RnV1nm/pub?w=960&h=720"/>

<Notes>

This is great, it looks like this implementation should work.. but are we sure it's production ready?

So let's say we deploy couple of replicas of our loadbalancer on production in front of some microservice and let
it run for longer time.

As soon as it starts running, we hit /lb endpoint manually and we can it works. So we are good, right?

Well...

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vT4N2dSOi0FhqFx1yVeNYPlJk6kT8o-7FdgvXvwpXiWVkK9MKM4SLflq4o3rJni9hEjWjrs7HKg0iOr/pub?w=960&h=720"/>

<Notes>

     Does it actually work for 100% users or only me?
     I have better things to do then manually hitting /lb endpoint to check if it works constantly, right?
     Are all request fast enough?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vTOKGrz6rfXVoHSfdNY4Pe901pdaJizjylwqyhkwMU53bRy9VXAJE4hTfGJrGiDncfg3Coh7Par67lu/pub?w=960&h=720"/>

<Notes>

    Is discovery really working? How many replicas it discovers, e.g through DNS?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vR-mA1zdYoQ-6pPjcSZFGTNIH1RV_3_VymMYOW1Y_OblYxiNoW-R-PBIVGHjNTHeyqiA-H9GIcZnQ6p/pub?w=960&h=720"/>

<Notes>

    Is round robin picker, picking in round robin matter?
    Is 1/3 of all requests actually going to replica 1? What's the distribution?
    Why one backend is overloaded with request?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vTxiQx99iCG7WgA2sfceWofNnol0ynukyDZ3iCoOY02CDcyvkHIJC4J4SQvSYMYAbiDjbhs_3WWsGCr/pub?w=960&h=720"/>

<Notes>

   Users reports that endpoint is slow, is it backend or latency of target of latency of loadbalancing?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vRz638FUDhV2SGsC5bco5wVnE0VHb_OLU6g4SaOL108D1KZLXkzmTgSHz6d-d-OPYkij2BzA27FVio2/pub?w=960&h=720"/>

<Notes>

  One of the nodes that loadbalancer running on OOM-ed, how much resources loadbalancer even use? Do we have a leak?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Wait... Anything missing?</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vTTmGW2ky_qxu9TEYUsnvQwHBe0lhTSc07UHHSCRsjHldVwm2fR2GpIEHZkZD5HbW3hObU4TXJnN7N4/pub?w=960&h=720"/>

<Notes>

  What version of binary we were running 2 days ago at 2pm? Something was wrong back then.

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;"> We need: Observability!</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vSvJ_htd2Q-qEzCkxjl057HEiGpnP97JLSdHVtjqlH4_huRIp8kgmhD0vRbufTCF4UWjkuje-l2Lli8/pub?w=960&h=720"/>

<Notes>

  As you can see there are plenty of questions that would be not answered when running service like this on
  production, without proper monitoring. That's why in SRE book you will find monitorin as the foundation
  of any system, BEFORE even the system itself!

  As you are familiar the some monitoring signals we can introduce are: traces, logs and metrics.
  Guess what Which of those will give us answer to our questions like distribution of requests or histogram of tail latency?

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;"> Let's instrument our loadbalancer with Prometheus metrics!</h2>
<br/>
<br/>

<Appear>
<span>Cheap</span>
<span>Near Real Time</span>
<span>Aggregate-able & Actionable = Alerts</span>
<div>
    <img src={prometheus} style="height: 50%; margin: auto; display: block; margin-top: 100px;" />
    <p>http://prometheus.io</p>

</div>
</Appear>

<Notes>

	Metrics, yup!

	Metrics will give us the answer to our question. Answer that is in comparison to logs and traces:

	* CHEAP to calculate
	* Near Real Time
    * Clear and Actionable, so you can alert on those.

    In practice metrics should be the first item on monitoring list that you should do if you care to run
    your service reliably.

    Appear:

    Why Prometheus though? Well I might be bias but Prometheus is currently one of the simplest and
    cheapest option for collecting, storing and querying metrics as well as reliable alerting.
    It fits for small solution as well as for bigger ones with help of projects like Thanos, Cortex, m3db and others

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;"> Let's instrument our loadbalancer with Prometheus metrics!</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vREgXi-KbyUIdbSbaFsIQbkWE7ZrcPA0cBya53PB-jfIRL1E6uMvJC4HUc4Ca9Rujizv_-zQhEr3P_O/pub?w=960&h=720"/>

<Notes>

    So.. how to add Prometheus metrics to our loadbalancer? Let's say we want to add counter of requests made
    to our loadbalancer server instance. We can add this counter in few simple steps.

</Notes>

---

<CodeSurfer>

```go title="Server HTTP request counter: Simple example"

import "github.com/prometheus/client_golang/prometheus"

```

```go 5,6,7,8,9,10 title="Server HTTP request counter: Simple example"

import "github.com/prometheus/client_golang/prometheus"

var (
	serverRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"code", "method"},
	)
)

```

```go 13,14,18,19 title="Server HTTP request counter: Simple example"

import "github.com/prometheus/client_golang/prometheus"

var (
	serverRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"code", "method"},
	)
)

// Top level ServerHTTP handler.
func ServerHTTP(w http.ResponseWriter, r *http.Request) {
  statusRec := newStatusRecorder(w)
  next.ServeHTTP(statusRec, r)

  // Increment our counter with written status code and request method.
  serverRequestsTotal.WithLabelValues(statusRec.Status(), r.Method)).Inc()
}

```

```go 23 title="Server HTTP request counter: Simple example"

import "github.com/prometheus/client_golang/prometheus"

var (
	serverRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"code", "method"},
	)
)

// Top level ServerHTTP handler.
func ServerHTTP(w http.ResponseWriter, r *http.Request) {
  statusRec := newStatusRecorder(w)
  next.ServeHTTP(statusRec, r)

  // Increment our counter with written status code and request method.
  serverRequestsTotal.WithLabelValues(statusRec.Status(), r.Method)).Inc()
}

func init() {
	prometheus.MustRegister(serverRequestsTotal)
}

```

</CodeSurfer>

<Notes>

</Notes>

---

<CodeSurferColumns>

<Step title="Server HTTP request counter: Simple example">

```go 3

func init() {
	prometheus.MustRegister(serverRequestsTotal)
}

```

<img src="https://docs.google.com/drawings/d/e/2PACX-1vREgXi-KbyUIdbSbaFsIQbkWE7ZrcPA0cBya53PB-jfIRL1E6uMvJC4HUc4Ca9Rujizv_-zQhEr3P_O/pub?w=960&h=720"/>

</Step>
<Step title="Server HTTP request counter: Simple example">

```go 7,12

func init() {
	prometheus.MustRegister(serverRequestsTotal)
}

mux := http.NewServeMux()
mux.Handle("/metrics", promhttp.Handler())
mux.Handle("/lb", ...)

// Other handlers...

srv := &http.Server{Handler: mux}

// Run server...

```

<img src="https://docs.google.com/drawings/d/e/2PACX-1vRcDyIrN_3tzI_QbA99QkvMHAHDIZZi-sh1stXoul_M-zyM1GQPdOCvC_h8nU91l-uQ-UUKjhuGhlYj/pub?w=960&h=720"/>

</Step>
</CodeSurferColumns>

<Notes>

So what we accomplished?

</Notes>

---

<h2 style="text-align: center; margin: 0px 10px 0 10px;">Prometheus can now collect metrics from our Loadbalancer</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vQazezdwEI7-_Naf_aMSGipdrSNMoDgc9YtrFyO_ttl1kuyeI7jn8lFtfVk8jQ35BQEAg2m8CvYGp3r/pub?w=590&h=701"/>

<Notes>

So what we accomplished?

</Notes>

---

import graph_requests from './static/graph-requests.png'

<CodeSurfer>

```go 4,6 title="From code to graph" subtitle="code"
var (
	serverRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"code", "method"},
	)
)

```

```go 4,6,12,13 title="From code to graph" subtitle="/metric"
var (
	serverRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"code", "method"},
	)
)

# HELP http_requests_total Tracks the number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{code="200",handler="/lb",method="get"} 1089
http_requests_total{code="500",handler="/lb",method="get"} 46

```

</CodeSurfer>

<Notes>

So what we accomplished?

</Notes>

---

<h2 style="text-align: center; margin: 0px 10px 0 10px;">Graph: Prometheus UI</h2>

<img src={graph_requests} style="height: 70%; margin-top: 5%"/>

<Notes>

So what we accomplished?

</Notes>

---

import pitfalls from './static/pitfalls.png'

<h1 style="text-align: center; margin: 0px 10px 0 10px;">Pitfalls</h1>

<img src={pitfalls} style="height: 50%; margin-top: 5%"/>

<Notes>
    Especially when we talk about libraries.. but.. most of our code is technically libraries. If you want to be
    friendly open source project any of your packages (unless to hide those under `internal`) can be reused
    by other projects. In fact probably you want those to be reused to join forces, have more hands to help on
    particular functionality that your package gives.

	 Now, even if you don't care about reusing in other project, your project is using your own package as library as well,
	 so it's crucial to allow certain flexibility, and some of the pitfalls we will be looking at are limiting use of
	 your Go package.
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #1: Globals</h2>

<Notes>
	Bartek
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #2: No Reuse</h2>

<Notes>

Middlewares/Tripperwares

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #2: No Reuse</h2>

<img src="https://docs.google.com/drawings/d/e/2PACX-1vSbAYa7dP3_Gt6sU04lUpwLaVsZ3eeOfhb5eogcwrcxBm00faptAZOnB6kSVMEtJ9XGShF1ZcCLTRBt/pub?w=960&h=720"/>

<Notes>

Middlewares/Tripperwares

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #3: Naming convention</h2>

<Notes>

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #4: Harcoding project name</h2>

<Notes>

</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #5: Unbounded Cardinality</h2>

<Notes>
	TODO: Kemal

	Add path or similar to labels
	Show bad example of passing raw error as label name of lbtransport metric for fails (!): https://github.com/observatorium/observable-demo/blob/master/pkg/lbtransport/transport.go#L38
	Why it matters, instead do as here: prepare predefine reasons: https://github.com/observatorium/observable-demo/blob/master/pkg/lbtransport/transport.go#L38.
</Notes>

---

<CodeSurfer>

```go title="Unbounded Cardinality" 7:14

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

```

```go 24:28

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(err).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

```

```git
# HELP conntrack_dialer_conn_failed_total Total number of connections failed to dial by the dialer.
# TYPE conntrack_dialer_conn_failed_total counter
conntrack_dialer_conn_failed_total{reason="<nil>"} 1
conntrack_dialer_conn_failed_total{reason="lookup example.com on localhost: err..."} 1
conntrack_dialer_conn_failed_total{reason="lookup thanos.io on 8.8.8.8: err..."} 1
conntrack_dialer_conn_failed_total{reason="lookup redhat.com on localhost: err..."} 1
conntrack_dialer_conn_failed_total{reason="syscall: unimplemented EpollWait"} 1
conntrack_dialer_conn_failed_total{reason="syscall.SIGINT: series of unfortunate things happened"} 1
conntrack_dialer_conn_failed_total{reason="unix: test returned fd in TestEpoll"} 1
conntrack_dialer_conn_failed_total{reason="Invalid value for argument: client: nil"} 1
```

</CodeSurfer>

<Notes>

TODO: Kemal !!

</Notes>

---

# 😲

---


<CodeSurfer>

```go 5:11,22:25

// ...

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(err).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

```

```go

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

// ...

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(err).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

```


```go

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

// ...

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(dialErrToReason(err)).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

```

```go

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

// ...

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(dialErrToReason(err)).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

func dialErrToReason(err error) string {
	if netErr, ok := err.(*net.OpError); ok {

		switch nestErr := netErr.Err.(type) {
		case *net.DNSError:
			return failedResolution

		case *os.SyscallError:
			if nestErr.Err == syscall.ECONNREFUSED {
				return failedConnRefused
			}
			return failedUnknown
		}

		if netErr.Timeout() {
			return failedTimeout
		}
	}

	return failedUnknown
}

```

```go 42[14:27],43,46[15:50],47,49,52[9:27],53,57

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

// ...

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

func dialClientConnTracker(...) (net.Conn, error) {
	conn, err := parentDialContextFunc(ctx, ntk, addr)
	if err != nil {
		metrics.connFailedTotal.WithLabelValues(dialErrToReason(err)).Inc()
		return conn, err
	}

	return &clientConnTracker{...}, nil
}

func dialErrToReason(err error) string {
	if netErr, ok := err.(*net.OpError); ok {

		switch nestErr := netErr.Err.(type) {
		case *net.DNSError:
			return failedResolution

		case *os.SyscallError:
			if nestErr.Err == syscall.ECONNREFUSED {
				return failedConnRefused
			}
			return failedUnknown
		}

		if netErr.Timeout() {
			return failedTimeout
		}
	}

	return failedUnknown
}

```

</CodeSurfer>

<Notes>
	TODO: Kemal
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #6: Not initializing Metrics</h2>

<Notes>
	TOOD: Kemal
	Counter Metrics are fine, CounterVec!!
</Notes>

---

<CodeSurfer>

```go title="Not initializing Metrics"

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

```

```go title="Not initializing Metrics"
m.connFailedTotal.WithLabelValues("unknown").Add(30)
```

</CodeSurfer>

<Notes>
	TODO: Kemal
</Notes>

---

import uninitialized_metrics from './static/uninitialized_metrics.png'

<Image src={uninitialized_metrics} size='contain'/>

<Notes>
	TODO: Kemal
</Notes>

---

import uninitialized_metrics_marked from './static/uninitialized_metrics_marked.png'

<Image src={uninitialized_metrics_marked} size='contain'/>

<Notes>
	TODO: Kemal
</Notes>

---

<CodeSurfer>

```go title="Not initializing Metrics"

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

```

```go title="Not initializing Metrics"

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	return m
}

```

```go title="Not initializing Metrics"

const (
	failedResolution  = "resolution"
	failedConnRefused = "refused"
	failedTimeout     = "timeout"
	failedUnknown     = "unknown"
)

type DialerMetrics struct {
	connFailedTotal      *prometheus.CounterVec
}

func NewDialerMetrics(reg prometheus.Registerer) *DialerMetrics {
	m := &DialerMetrics{
		connFailedTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Subsystem: "conntrack",
				Name:      "dialer_conn_failed_total",
				Help:      "Total number of connections failed to dial by the dialer.",
			}, []string{"reason"}),
	}

	if reg != nil {
		reg.MustRegister(m.connClosedTotal)
	}

	// Initialize metric with labels.
	// It is possible to call this method without using the returned Counter to only
	// create the new Counter but leave it at its starting value 0.
	m.connFailedTotal.WithLabelValues(failedResolution)
	m.connFailedTotal.WithLabelValues(failedConnRefused)
	m.connFailedTotal.WithLabelValues(failedTimeout)
	m.connFailedTotal.WithLabelValues(failedUnknown)

	return m
}

```

```go title="Not initializing Metrics"
m.connFailedTotal.WithLabelValues("unknown").Add(30)
```

</CodeSurfer>

<Notes>
	TODO: Kemal

	BTW: Counters without labels are initialized without an additional step.
</Notes>

---

import initialized_metrics from './static/initialized_metrics.png'

<Image src={initialized_metrics} size='contain'/>

<Notes>
	TODO: Kemal
</Notes>

---

import initialized_metrics_marked from './static/initialized_metrics_marked.png'

<Image src={initialized_metrics_marked} size='contain'/>

<Notes>
	TODO: Kemal
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #7: Poorly chosen Histogram buckets</h2>

---

<CodeSurfer>

```go title="Poorly chosen Histogram buckets"

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```go title="Poorly chosen Histogram buckets" 13

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 1
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.01"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.1"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.3"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.6"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="3"} 49
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 49
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.11527970000000001
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 49

```

```go title="Poorly chosen Histogram buckets" 13

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.0000001, 0.000001, 0.00001, 0.00003, 0.00006, 0.001, 0.03},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1e-07"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1e-06"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1e-05"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="3e-05"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="6e-05"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 1
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.03"} 23
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 23
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.0636401
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 23

```

```go title="Poorly chosen Histogram buckets" 13

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: prometheus.LinearBuckets(0.001, 0.0002, 6),
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 3
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.0012000000000000001"} 3
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.0014000000000000002"} 10
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.0016000000000000003"} 21
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.0018000000000000004"} 25
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.0020000000000000005"} 29
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 49
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.10939249999999999
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 49

```

```go title="Poorly chosen Histogram buckets"

DefaultBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10}
prometheus.ExponentialBuckets(.1, 1.5, 5),
prometheus.LinearBuckets(.01, .01, 10)

```

</CodeSurfer>

<Notes>
	TODO: Kemal
	Show metrics with yolo many buckets
	Problem: Cardinality (explain why)
	Solution: SLO based!

	Use real life example, too large request or too small requests
	Too many buckets
	Too less buckets
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #8: Histogram Cardinality Explosion</h2>

---

<CodeSurfer>

```go title="Histogram Cardinality Explosion"

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```go title="Histogram Cardinality Explosion"

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3, 6, 9, 20, 30, 60, 90, 120},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.01"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.1"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.3"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.6"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="3"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="6"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="9"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="20"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="30"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="60"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="90"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="120"} 30
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 30
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.08239999999999999
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 30

```

```go title="Histogram Cardinality Explosion" 13

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
				Buckets: []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3, 6, 9, 20, 30, 40, 50, 60, 90, 120, 150, 200},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.01"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.1"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.3"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.6"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="3"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="6"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="9"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="20"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="30"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="40"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="50"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="60"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="90"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="120"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="150"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="200"} 18
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 18
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.0480237
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 18

```

```console

➜ curl -XPOST localhost:8080/lb
localhost:8082 says hello! (:

```

</CodeSurfer>

---

# 💥

<Notes>
	TODO: Kemal
	Show metrics with yolo many buckets
	Problem: Cardinality (explain why)
	Solution: SLO based!

	Use real life example, too large request or too small requests
	Too many buckets
	Too less buckets
</Notes>

---

<CodeSurfer>

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="0.001"} 0
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="0.01"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="0.1"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="0.3"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="0.6"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="1"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="3"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="6"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="9"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="20"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="30"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="40"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="50"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="60"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="90"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="120"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="150"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="200"} 2
http_request_duration_seconds_bucket{code="200",handler="/lb",method="post",le="+Inf"} 2
http_request_duration_seconds_sum{code="200",handler="/lb",method="post"} 0.0026940999999999996
http_request_duration_seconds_count{code="200",handler="/lb",method="post"} 2
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.001"} 0
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.01"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.1"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.3"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.6"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="3"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="6"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="9"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="20"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="30"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="40"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="50"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="60"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="90"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="120"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="150"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="200"} 146
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 146
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.3082099000000001
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 146
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="0.001"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="0.01"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="0.1"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="0.3"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="0.6"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="1"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="3"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="6"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="9"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="20"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="30"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="40"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="50"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="60"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="90"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="120"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="150"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="200"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-500-sometimes",method="post",le="+Inf"} 1
http_request_duration_seconds_sum{code="200",handler="demo-500-sometimes",method="post"} 4.01e-05
http_request_duration_seconds_count{code="200",handler="demo-500-sometimes",method="post"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="0.001"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="0.01"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="0.1"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="0.3"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="0.6"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="1"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="3"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="6"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="9"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="20"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="30"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="40"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="50"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="60"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="90"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="120"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="150"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="200"} 1
http_request_duration_seconds_bucket{code="200",handler="demo-refused-conn-sometimes",method="post",le="+Inf"} 1
http_request_duration_seconds_sum{code="200",handler="demo-refused-conn-sometimes",method="post"} 4.46e-05
http_request_duration_seconds_count{code="200",handler="demo-refused-conn-sometimes",method="post"} 1

```

</CodeSurfer>

---

<Image src={ss_tsdb_01} size='contain'/>

<Notes>

TODO: Kemal !!

Promdash head cardinality screeen

</Notes>


---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #9: Histogram vs Summary</h2>

---

<CodeSurfer>

```go title="Histogram vs Summary"

type ServerMetrics struct {
	requestDuration  *prometheus.HistogramVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "http_request_duration_seconds",
				Help:    "Tracks the latencies for HTTP requests.",
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.005"} 58
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.01"} 71
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.025"} 75
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.05"} 80
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.1"} 80
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.25"} 81
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="0.5"} 82
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="1"} 82
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="2.5"} 82
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="5"} 82
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="10"} 82
http_request_duration_seconds_bucket{code="200",handler="/metrics",method="get",le="+Inf"} 82
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 1.0698880999999996
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 82

```

```go title="Histogram vs Summary"

type ServerMetrics struct {
	requestDuration  *prometheus.SummaryVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewSummaryVec(
			prometheus.SummaryOpts{
				Name: "http_request_duration_seconds",
				Help: "Tracks the latencies for HTTP requests.",
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds summary
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.15244579999999996
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 59

```

```go title="Histogram vs Summary" subtitle="Do not forget to set your objectives!"

type ServerMetrics struct {
	requestDuration  *prometheus.SummaryVec
}

// NewServerMetrics provides ServerMetrics.
func NewServerMetrics(reg prometheus.Registerer) *ServerMetrics {
	ins := &ServerMetrics{
		requestDuration: prometheus.NewSummaryVec(
			prometheus.SummaryOpts{
				Name: "http_request_duration_seconds",
				Help: "Tracks the latencies for HTTP requests.",
				Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
			},
			[]string{"code", "method"},
		),
	}
	reg.MustRegister(ins.requestDuration)
	return ins
}

```

```git

# HELP http_request_duration_seconds Tracks the latencies for HTTP requests.
# TYPE http_request_duration_seconds summary
http_request_duration_seconds{code="200",handler="/metrics",method="get",quantile="0.5"} 0.0018995
http_request_duration_seconds{code="200",handler="/metrics",method="get",quantile="0.9"} 0.0054216
http_request_duration_seconds{code="200",handler="/metrics",method="get",quantile="0.99"} 0.009909
http_request_duration_seconds_sum{code="200",handler="/metrics",method="get"} 0.0775536
http_request_duration_seconds_count{code="200",handler="/metrics",method="get"} 28

```

</CodeSurfer>

<Notes>
	TODO: Kemal
	Using summary where histogram would be cheaper, explain differences
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Pitfalls #10: Not Testing</h2>

TODO: Kemal - Fix title

---

<CodeSurfer>

```go title="Not testing"

type Metrics struct {
	successes prometheus.Counter
	failures  *prometheus.CounterVec
	duration  prometheus.Histogram
}

func NewMetrics(reg prometheus.Registerer) *Metrics {
	m := &Metrics{
		successes: prometheus.NewCounter(prometheus.CounterOpts{
			Subsystem: "lbtransport",
			Name:      "proxied_requests_total",
			Help:      "Total number successful proxy round trips.",
		}),
		failures: prometheus.NewCounterVec(prometheus.CounterOpts{
			Subsystem: "lbtransport",
			Name:      "proxied_failed_requests_total",
			Help:      "Total number failed proxy round trips.",
		}, []string{"reason"}),
		duration: prometheus.NewHistogram(
			prometheus.HistogramOpts{
				Subsystem: "lbtransport",
				Name:      "proxy_duration_seconds",
				Help:      "Duration of proxy logic.",
				Buckets:   []float64{0.001, 0.01, 0.1, 0.3, 0.6, 1, 3, 10},
			}),
	}

	if reg != nil {
		reg.MustRegister(m.successes, m.failures, m.duration)
	}

	return m
}

```

```go title="prometheus/testutil here to help"

import (
	"github.com/prometheus/client_golang/prometheus/testutil"
)

```
</CodeSurfer>

---

<CodeSurfer>

```go title="Not Testing"

struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	// ...
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		// ...
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	// ...
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
	}); !ok {
		return
	}
}

```

```go title="Not Testing" 15:21,25:33,34[5:7]

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)

		testutil.Equals(t, tcase.successes, promtestutil.ToFloat64(metrics.successes))
		testutil.Equals(t, tcase.failedNoTargetAvailable, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetAvailable)))
		testutil.Equals(t, tcase.failedNoTargetResolved, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetResolved)))
		testutil.Equals(t, tcase.failedUnknown, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedUnknown)))
		testutil.Equals(t, float64(0), promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedTimeout)))
		testutil.Equals(t, 4, promtestutil.CollectAndCount(lb.metrics.failures))
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)

		testutil.Equals(t, tcase.successes, promtestutil.ToFloat64(metrics.successes))
		testutil.Equals(t, tcase.failedNoTargetAvailable, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetAvailable)))
		testutil.Equals(t, tcase.failedNoTargetResolved, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetResolved)))
		testutil.Equals(t, tcase.failedUnknown, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedUnknown)))
		testutil.Equals(t, float64(0), promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedTimeout)))
		testutil.Equals(t, 4, promtestutil.CollectAndCount(lb.metrics.failures))
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
	{
		targets: []string{"a"},
		responses: []response{
			{host: "a", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
		},
		excluded:    []string{"a"},
		expectedErr: errors.New("lb: no target is available"),

		successes: 2, failedNoTargetAvailable: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)

		testutil.Equals(t, tcase.successes, promtestutil.ToFloat64(metrics.successes))
		testutil.Equals(t, tcase.failedNoTargetAvailable, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetAvailable)))
		testutil.Equals(t, tcase.failedNoTargetResolved, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetResolved)))
		testutil.Equals(t, tcase.failedUnknown, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedUnknown)))
		testutil.Equals(t, float64(0), promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedTimeout)))
		testutil.Equals(t, 4, promtestutil.CollectAndCount(lb.metrics.failures))
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
	{
		targets: []string{"a"},
		responses: []response{
			{host: "a", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
		},
		excluded:    []string{"a"},
		expectedErr: errors.New("lb: no target is available"),

		successes: 2, failedNoTargetAvailable: 1,
	},
	{
		targets:     []string{},
		expectedErr: errors.New("lb: no target was resolved"),

		successes: 2, failedNoTargetAvailable: 1, failedNoTargetResolved: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)

		testutil.Equals(t, tcase.successes, promtestutil.ToFloat64(metrics.successes))
		testutil.Equals(t, tcase.failedNoTargetAvailable, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetAvailable)))
		testutil.Equals(t, tcase.failedNoTargetResolved, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetResolved)))
		testutil.Equals(t, tcase.failedUnknown, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedUnknown)))
		testutil.Equals(t, float64(0), promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedTimeout)))
		testutil.Equals(t, 4, promtestutil.CollectAndCount(lb.metrics.failures))
	}); !ok {
		return
	}
}

```

```go title="Not Testing"

for _, tcase := range []struct {
	targets   []string
	responses []response
	excluded  []string

	expectedHost string
	expectedErr  error

	failedNoTargetAvailable float64
	failedNoTargetResolved  float64
	failedUnknown           float64
	successes               float64
}{
	{
		targets:      []string{"a"},
		responses:    []response{okResponse("a")},
		expectedHost: "a",

		successes: 1,
	},
	{
		targets: []string{"a"},
		responses: []response{
			{host: "a", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
		},
		excluded:    []string{"a"},
		expectedErr: errors.New("lb: no target is available"),

		successes: 2, failedNoTargetAvailable: 1,
	},
	{
		targets:     []string{},
		expectedErr: errors.New("lb: no target was resolved"),

		successes: 2, failedNoTargetAvailable: 1, failedNoTargetResolved: 1,
	},
	{
		targets: []string{"a", "b", "c", "d", "e", "f", "g"},
		responses: []response{
			{host: "a", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			{host: "b", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			{host: "c", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			{host: "d", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			{host: "e", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			{host: "f", err: &net.OpError{Op: "dial", Err: syscall.ECONNREFUSED}},
			okResponse("g"),
		},
		excluded:     []string{"a", "b", "c", "d", "e", "f"},
		expectedHost: "g",

		successes: 3, failedNoTargetAvailable: 1, failedNoTargetResolved: 1,
	},
} {
	if ok := t.Run("", func(t *testing.T) {
		reset(tcase)

		resp, err := lb.RoundTrip(httptest.NewRequest("GET", "http://whatever", nil))
		if tcase.expectedErr != nil {
			testutil.NotOk(t, err)
			testutil.Equals(t, tcase.expectedErr.Error(), err.Error())
		} else {
			testutil.Ok(t, err)
			testutil.Equals(t, tcase.expectedHost, resp.Request.URL.Host)
		}
		testutil.Equals(t, tcase.excluded, picker.excluded)
		testutil.Equals(t, discovery.Targets(), picker.lastSeenTargets)

		testutil.Equals(t, tcase.successes, promtestutil.ToFloat64(metrics.successes))
		testutil.Equals(t, tcase.failedNoTargetAvailable, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetAvailable)))
		testutil.Equals(t, tcase.failedNoTargetResolved, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedNoTargetResolved)))
		testutil.Equals(t, tcase.failedUnknown, promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedUnknown)))
		testutil.Equals(t, float64(0), promtestutil.ToFloat64(metrics.failures.WithLabelValues(failedTimeout)))
		testutil.Equals(t, 4, promtestutil.CollectAndCount(lb.metrics.failures))
	}); !ok {
		return
	}
}

```

</CodeSurfer>

<Notes>
	TODO: Kemal
	No tests
	Solution: testutil! lbtransport metrics, reliability! Shows how you can use metrics, what behaviour to expect!

	You have some metrics to test!
	But it's hard to write tests!

	prometheus/testutil here to help
</Notes>

---

<h2 style="text-align: center; margin: 0 10px 0 10px;">Sum things Up? Summary?</h2>

---

# Summary

<ul>
	<Appear>
		<li>Pitfall #1</li>
		<li>Pitfall #2</li>
		<li>Pitfall #3</li>
		<li>Pitfall #4</li>
		<li>Pitfall #5</li>
		<li>Pitfall #6</li>
		<li>Pitfall #7</li>
		<li>Pitfall #8</li>
		<li>Pitfall #9</li>
		<li>Pitfall #10</li>
	</Appear>
</ul>

## TODO: Kemal

<Notes>
	TODO: Kemal
</Notes>

---

# Thank you!

<img src="https://raw.githubusercontent.com/kakkoyun/are-you-testing-your-observability/master/static/red_hat_white.png" style="height: 20%"/>

Reference:
* [Observable Demo](https://github.com/observatorium/observable-demo)
* [Slides](https://github.com/kakkoyun/are-you-testing-your-observability)
* [Thanos](https://thanos.io)
* [Prometheus](https://prometheus.io)
* [Prometheus - client_go](https://godoc.org/github.com/prometheus/client_golang/prometheus/testutil)
* [Prometheus - Histogram](https://prometheus.io/docs/practices/histograms/)
* [Prometheus Histograms – Past, Present, and Future](https://www.youtube.com/watch?v=7sQFkaMCyEI)
* [Roboust Perception - Cardinality is the key](https://www.robustperception.io/cardinality-is-key)
* [Gopherize me](https://gopherize.me/)
